// Code generated by {{Generator}}; DO NOT EDIT.

package block

import (
	"errors"
	"strconv"
)
{{range $prop := .}}
type {{.Name}} byte

const (
{{- range $index, $element := .Values}}
    {{if not $prop.TrimPrefix}}{{$prop.Name}}{{end}}{{$element | UpperTheFirst}}{{if eq $index 0 }} {{$prop.Name}} = iota{{end}}
{{- end}}
)

{{- $v := slice (.Name | ToLower) 0 1 }}
var str{{.Name}} = [...]string{ {{- range $index, $elem := .Values }}{{$elem | printf "%q"}}{{if ne $index (len $prop.Values)}}, {{end}}{{end -}} }

func ({{$v}} {{.Name}}) String() string {
	if int({{$v}}) < len(str{{.Name}}) {
		return str{{.Name}}[{{$v}}]
	}
	return "invalid {{.Name}}"
}

func ({{$v}} {{.Name}}) MarshalText() (text []byte, err error) {
	if int({{$v}}) < len(str{{.Name}}) {
		return []byte(str{{.Name}}[{{$v}}]), nil
	}
	return nil, errors.New("invalid {{.Name}}: " + strconv.Itoa(int({{$v}})))
}

func ({{$v}} *{{.Name}}) UnmarshalText(text []byte) error {
	switch str := string(text); str {
{{- range .Values}}
	case {{. | printf "%q"}}:
		*{{$v}} = {{if not $prop.TrimPrefix}}{{$prop.Name}}{{end}}{{. | UpperTheFirst}}
{{- end}}
	default:
		return errors.New("unknown {{.Name}}: " + str)
	}
	return nil
}
{{end}}